<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Screen Mirror - Broadcaster (PC1)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 40px;
            max-width: 600px;
            width: 100%;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            color: #333;
            font-weight: 500;
            margin-bottom: 8px;
            font-size: 14px;
        }

        input {
            width: 100%;
            padding: 12px 14px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input:focus {
            outline: none;
            border-color: #667eea;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 20px;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-danger {
            background: #ff6b6b;
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #ee5a52;
            transform: translateY(-2px);
        }

        .btn-danger:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 14px;
            font-weight: 500;
        }

        .status.disconnected {
            background: #ffe0e0;
            color: #d32f2f;
            border-left: 4px solid #d32f2f;
        }

        .status.connecting {
            background: #fff3cd;
            color: #856404;
            border-left: 4px solid #ffc107;
        }

        .status.connected {
            background: #d4edda;
            color: #155724;
            border-left: 4px solid #28a745;
        }

        .status.streaming {
            background: #cfe8fc;
            color: #004085;
            border-left: 4px solid #0056b3;
        }

        .info-box {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 13px;
            color: #555;
            line-height: 1.6;
        }

        .viewers-list {
            margin-top: 20px;
        }

        .viewers-list h3 {
            color: #333;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .viewer-item {
            background: #f5f5f5;
            padding: 10px 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 13px;
            color: #555;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .viewer-item .badge {
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
        }

        .spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
            vertical-align: middle;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .link-section {
            margin-top: 20px;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 8px;
        }

        .link-section h4 {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .link-display {
            background: white;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
            font-size: 12px;
            word-break: break-all;
            color: #333;
            font-family: monospace;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>üì∫ Screen Mirror</h1>
        <p class="subtitle">PC1 - Broadcaster</p>

        <div id="status" class="status disconnected">
            <span id="statusText">Not connected</span>
        </div>

        <div class="input-group">
            <label for="roomId">Room ID (share with viewer)</label>
            <input type="text" id="roomId" placeholder="e.g., room123" value="">
        </div>

        <div class="button-group">
            <button id="startBtn" class="btn-primary">Start Broadcasting</button>
            <button id="stopBtn" class="btn-primary" disabled>Stop Broadcasting</button>
        </div>

        <div
            style="margin-top: 20px; padding: 15px; background: #f5f5f5; border-radius: 8px; border: 2px solid #e0e0e0;">
            <h3 style="margin-bottom: 10px; color: #333; font-size: 14px;">üìπ Local Preview</h3>
            <video id="localPreview" autoplay playsinline muted
                style="width: 100%; max-height: 300px; background: #000; border-radius: 6px; display: none;"></video>
            <div id="previewPlaceholder"
                style="width: 100%; height: 200px; background: #000; border-radius: 6px; display: flex; align-items: center; justify-content: center; color: #666; font-size: 13px;">
                Your screen will appear here after clicking "Start Broadcasting"
            </div>
        </div>

        <div class="link-section">
            <h4>Share this link with viewers:</h4>
            <div class="link-display" id="shareLink">
                Waiting for broadcast to start...
            </div>
        </div>

        <div class="viewers-list" id="viewersList" style="display: none;">
            <h3>Connected Viewers</h3>
            <div id="viewersContainer"></div>
        </div>

        <div class="info-box">
            <strong>‚ÑπÔ∏è Instructions:</strong><br>
            1. Enter a Room ID or generate one<br>
            2. Click "Start Broadcasting" to share your screen<br>
            3. Grant browser permissions for screen & audio capture<br>
            4. Share the link or Room ID with another PC<br>
            5. They'll see your screen in real-time with audio
        </div>
    </div>

    <script>
        const roomIdInput = document.getElementById('roomId');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const status = document.getElementById('status');
        const statusText = document.getElementById('statusText');
        const shareLink = document.getElementById('shareLink');
        const viewersList = document.getElementById('viewersList');
        const viewersContainer = document.getElementById('viewersContainer');
        const localPreview = document.getElementById('localPreview');
        const previewPlaceholder = document.getElementById('previewPlaceholder');

        let ws;
        let peerConnections = new Map();
        let roomId;
        let mediaStream;
        let isStreaming = false;

        // Generate room ID if empty
        if (!roomIdInput.value) {
            roomIdInput.value = 'room-' + Math.random().toString(36).substr(2, 9);
        }

        function updateStatus(message, type) {
            statusText.textContent = message;
            status.className = `status ${type}`;
        }

        function connectWebSocket() {
            return new Promise((resolve, reject) => {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}`;

                ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                    console.log('WebSocket connected');
                    updateStatus('Connected to server', 'connected');
                    resolve();
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    handleSignalingMessage(data);
                };

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateStatus('Connection error', 'disconnected');
                    reject(error);
                };

                ws.onclose = () => {
                    console.log('WebSocket closed');
                    updateStatus('Disconnected from server', 'disconnected');
                };
            });
        }

        async function startBroadcasting() {
            try {
                roomId = roomIdInput.value.trim();
                if (!roomId) {
                    alert('Please enter a Room ID');
                    return;
                }

                console.log('üé¨ Starting broadcast for room:', roomId);
                updateStatus('Requesting screen & audio...', 'connecting');

                // Capture screen with audio
                console.log('üì∑ Requesting display media...');

                // Try with audio first, fall back to video only
                try {
                    mediaStream = await navigator.mediaDevices.getDisplayMedia({
                        video: {
                            cursor: 'always',
                            width: { ideal: 3840 },  // 4K resolution
                            height: { ideal: 1080 },
                            frameRate: { ideal: 30 }  // 60 FPS for smooth motion
                        },
                        audio: {
                            echoCancellation: false,      // Preserve full audio quality
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: { ideal: 48000 }  // High sample rate
                        }
                    });
                } catch (error) {
                    // If audio fails with these constraints, try video only
                    console.warn('‚ö†Ô∏è  Audio capture failed, trying video only:', error.message);
                    mediaStream = await navigator.mediaDevices.getDisplayMedia({
                        video: {
                            cursor: 'always',
                            width: { ideal: 3840 },
                            height: { ideal: 2160 },
                            frameRate: { ideal: 60 }
                        }
                    });
                }

                console.log('‚úì Display media captured');
                console.log('  Tracks:', mediaStream.getTracks().map(t => `${t.kind}(${t.enabled})`).join(', '));

                // Show local preview
                console.log('üìπ Attaching to local preview...');
                localPreview.srcObject = mediaStream;
                localPreview.style.display = 'block';
                previewPlaceholder.style.display = 'none';
                console.log('‚úì Local preview visible');

                // Connect WebSocket if not already connected
                if (!ws || ws.readyState !== WebSocket.OPEN) {
                    console.log('üì° Connecting WebSocket...');
                    await connectWebSocket();
                }

                // Join room as broadcaster
                const clientId = 'broadcaster-' + Date.now();
                console.log('üöÄ Joining room as broadcaster:', clientId);
                ws.send(JSON.stringify({
                    type: 'join',
                    roomId: roomId,
                    role: 'broadcaster',
                    clientId: clientId
                }));

                isStreaming = true;
                updateStatus('Broadcasting started', 'streaming');
                startBtn.disabled = true;
                stopBtn.disabled = false;
                roomIdInput.disabled = true;

                // Update share link
                const viewerUrl = `${window.location.origin}/viewer.html?room=${encodeURIComponent(roomId)}`;
                shareLink.textContent = viewerUrl;
                console.log('üì§ Share URL:', viewerUrl);

                // Handle stream end
                mediaStream.getTracks().forEach(track => {
                    track.onended = () => {
                        console.log('‚ö†Ô∏è  Stream track ended:', track.kind);
                        stopBroadcasting();
                    };
                });

            } catch (error) {
                console.error('‚ùå Broadcast error:', error);
                console.error('   Name:', error.name);
                console.error('   Message:', error.message);

                if (error.name === 'NotAllowedError') {
                    updateStatus('Permission denied - screen capture cancelled', 'disconnected');
                    console.log('User cancelled screen capture');
                } else if (error.name === 'NotFoundError') {
                    updateStatus('No display found to capture', 'disconnected');
                } else if (error.name === 'NotSupportedError') {
                    updateStatus('Screen capture not supported in this browser', 'disconnected');
                } else {
                    updateStatus('Error: ' + error.message, 'disconnected');
                }
            }
        }

        function stopBroadcasting() {
            isStreaming = false;

            // Stop all tracks
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }

            // Hide local preview
            localPreview.srcObject = null;
            localPreview.style.display = 'none';
            previewPlaceholder.style.display = 'flex';

            // Close peer connections
            peerConnections.forEach(pc => {
                pc.close();
            });
            peerConnections.clear();

            updateStatus('Broadcasting stopped', 'disconnected');
            startBtn.disabled = false;
            stopBtn.disabled = true;
            roomIdInput.disabled = false;
            viewersList.style.display = 'none';
            viewersContainer.innerHTML = '';
        }

        function handleSignalingMessage(data) {
            if (data.type === 'joined') {
                console.log('Joined as broadcaster');
            } else if (data.type === 'viewer-connected') {
                console.log('Viewer connected:', data.viewerId);
                createPeerConnection(data.viewerId);
                updateViewersList();
            } else if (data.type === 'viewer-disconnected') {
                console.log('Viewer disconnected');
                if (peerConnections.has(data.viewerId)) {
                    peerConnections.get(data.viewerId).close();
                    peerConnections.delete(data.viewerId);
                }
                updateViewersList();
            } else if (data.type === 'answer') {
                console.log('üì• Received ANSWER from viewer:', data.viewerId);
                const pc = peerConnections.get(data.viewerId);
                if (pc) {
                    console.log('‚öôÔ∏è  Setting remote description (answer)...');
                    pc.setRemoteDescription(new RTCSessionDescription(data.answer)).then(() => {
                        console.log('‚úì Remote description set successfully');
                    }).catch(e => {
                        console.error('‚ùå Error setting remote description:', e);
                    });
                } else {
                    console.error('‚ùå No peer connection found for viewer:', data.viewerId);
                }
            } else if (data.type === 'ice-candidate') {
                const pc = peerConnections.get(data.viewerId);
                if (pc && data.candidate) {
                    pc.addIceCandidate(new RTCIceCandidate(data.candidate)).catch(e => console.error('Error adding ICE candidate:', e));
                }
            }
        }

        async function createPeerConnection(viewerId) {
            try {
                console.log('üîå Creating peer connection for viewer:', viewerId);

                /**
                const pc = new RTCPeerConnection({
                    iceServers: [
                        { urls: ['stun:stun.l.google.com:19302'] },
                        { urls: ['stun:stun1.l.google.com:19302'] },
                        { urls: ['stun:stun2.l.google.com:19302'] },
                        { urls: ['stun:stun3.l.google.com:19302'] },
                        { urls: ['stun:stun4.l.google.com:19302'] },
                        { urls: ['stun:stun.stunprotocol.org:3478'] },
                        // Public TURN servers for cross-network fallback
                        { 
                            urls: ['turn:openrelay.metered.ca:80'],
                            username: 'openrelayproject',
                            credential: 'openrelayproject'
                        },
                        { 
                            urls: ['turn:openrelay.metered.ca:443'],
                            username: 'openrelayproject',
                            credential: 'openrelayproject'
                        }
                    ],
                    iceCandidatePoolSize: 10,
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require'
                });
                **/

                /** TURN-only configuration for testing
                 const pc = new RTCPeerConnection({
                     iceServers: [
                         {
                             urls: [
                                 'turn:openrelay.metered.ca:80',
                                 'turn:openrelay.metered.ca:443',
                                 'turn:openrelay.metered.ca:443?transport=tcp'
                             ],
                             username: 'openrelayproject',
                             credential: 'openrelayproject'
                         }
                     ],
                     iceTransportPolicy: 'relay'  // ‚Üê Forces TURN only
                 });
                 **/

                // Get your TURN server IP (same machine or another on LAN)
                const TURN_SERVER_IP = '192.168.160.48';  // ‚Üê Your TURN server IP

                const pc = new RTCPeerConnection({
                    iceServers: [
                        {
                            urls: `turn:${TURN_SERVER_IP}:3478`,
                            username: 'username',
                            credential: 'password123'
                        }
                    ],
                    iceTransportPolicy: "all"
                });

                peerConnections.set(viewerId, pc);

                // Add media tracks
                if (mediaStream) {
                    console.log('üìπ Adding tracks to peer connection:');
                    const tracks = mediaStream.getTracks();
                    console.log(`   Total tracks: ${tracks.length}`);

                    tracks.forEach((track, idx) => {
                        console.log(`   ‚úì Track ${idx}: ${track.kind} (${track.enabled ? 'enabled' : 'disabled'}) - readyState: ${track.readyState}`);

                        // Monitor video track specifically
                        if (track.kind === 'video') {
                            console.log(`      Video track settings:`, track.getSettings());

                            // Keep video track unmuted at all times
                            track.onmute = () => {
                                console.warn('‚ö†Ô∏è  Video track muted, re-enabling...');
                                track.enabled = true;  // Force it back on
                            };
                            track.onunmute = () => console.log('‚úì Video track unmuted');
                            track.onended = () => console.error('‚ùå VIDEO TRACK ENDED!');

                            // Ensure track stays enabled
                            setInterval(() => {
                                if (!track.enabled) {
                                    console.warn('‚ö†Ô∏è  Video track disabled, re-enabling...');
                                    track.enabled = true;
                                }
                                if (track.readyState !== 'live') {
                                    console.error(`‚ö†Ô∏è  Video track state: ${track.readyState}`);
                                }
                            }, 1000);
                        }

                        try {
                            // Use addTrack with the stream - this is the correct way for display media
                            const sender = pc.addTrack(track, mediaStream);
                            console.log(`     ‚úÖ Sender added: ${sender.track.id}`);
                        } catch (e) {
                            console.error(`   Error adding track:`, e.message);
                        }
                    });
                    console.log('‚úì All tracks added successfully');
                } else {
                    console.error('‚ùå No media stream available!');
                }

                // Handle ICE candidates
                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        console.log('üì§ Broadcaster sending ICE candidate');
                        ws.send(JSON.stringify({
                            type: 'ice-candidate',
                            roomId: roomId,
                            to: 'viewer',
                            viewerId: viewerId,
                            candidate: event.candidate
                        }));
                    }
                };

                // Create and send offer
                console.log('üìã Creating offer...');
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                console.log('‚úì Offer created and set as local description');

                // Set high bitrate for maximum quality
                const senders = pc.getSenders();
                for (const sender of senders) {
                    if (sender.track) {
                        const params = sender.getParameters();
                        if (!params.encodings) {
                            params.encodings = [{}];
                        }
                        if (sender.track.kind === 'video') {
                            params.encodings[0].maxBitrate = 100000000; // 5 Mbps for video
                            console.log('üìπ Video bitrate set to 5 Mbps');
                        } else if (sender.track.kind === 'audio') {
                            params.encodings[0].maxBitrate = 320000; // 320 kbps for audio
                            console.log('üîä Audio bitrate set to 320 kbps');
                        }
                        await sender.setParameters(params);
                    }
                }

                console.log('üì§ Sending offer to viewer...');
                ws.send(JSON.stringify({
                    type: 'offer',
                    roomId: roomId,
                    to: 'viewer',
                    viewerId: viewerId,
                    offer: offer
                }));
                console.log('‚úì Offer sent');

                pc.onconnectionstatechange = () => {
                    console.log('üîó Broadcaster peer connection state:', pc.connectionState);
                    if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected' || pc.connectionState === 'closed') {
                        console.log('Removing viewer from connections');
                        peerConnections.delete(viewerId);
                        updateViewersList();
                    }
                };

                pc.oniceconnectionstatechange = () => {
                    console.log('üßä Broadcaster ICE connection state:', pc.iceConnectionState);
                };

                // Monitor WebRTC stats to see if data is flowing
                let statsInterval = setInterval(async () => {
                    if (!pc) {
                        clearInterval(statsInterval);
                        return;
                    }
                    console.log(`[STATS] Connection state: ${pc.connectionState}, ICE state: ${pc.iceConnectionState}`);

                    if (pc && (pc.connectionState === 'connected' || pc.connectionState === 'connecting')) {
                        try {
                            const stats = await pc.getStats();
                            stats.forEach(report => {
                                if (report.type === 'outbound-rtp') {
                                    if (report.kind === 'video') {
                                        console.log(`üìä Video sent: ${report.bytesSent} bytes, ${report.framesEncoded} frames`);
                                    }
                                    if (report.kind === 'audio') {
                                        console.log(`üìä Audio sent: ${report.bytesSent} bytes`);
                                    }
                                }
                                if (report.type === 'inbound-rtp') {
                                    if (report.kind === 'video') {
                                        console.log(`üìä Video received: ${report.bytesReceived} bytes`);
                                    }
                                }
                            });
                        } catch (e) {
                            console.error('Error getting stats:', e.message);
                        }
                    }
                }, 2000);

            } catch (error) {
                console.error('Error creating peer connection:', error);
            }
        }

        function updateViewersList() {
            if (peerConnections.size > 0) {
                viewersList.style.display = 'block';
                viewersContainer.innerHTML = '';
                peerConnections.forEach((pc, viewerId) => {
                    const state = pc.connectionState;
                    let stateColor = '#ffc107';
                    if (state === 'connected') stateColor = '#28a745';

                    const item = document.createElement('div');
                    item.className = 'viewer-item';
                    item.innerHTML = `
                        ${viewerId}
                        <span class="badge" style="background: ${stateColor}">${state}</span>
                    `;
                    viewersContainer.appendChild(item);
                });
            } else {
                viewersList.style.display = 'none';
            }
        }

        startBtn.addEventListener('click', startBroadcasting);
        stopBtn.addEventListener('click', stopBroadcasting);

        // Generate random room ID on load
        roomIdInput.value = 'room-' + Math.random().toString(36).substr(2, 9);
    </script>
</body>

</html>